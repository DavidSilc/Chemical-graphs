\documentclass{article}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{amsfonts} 
\usepackage[a4paper, margin=1in]{geometry} 
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{amsmath}


\newtheorem*{remark}{Remark}
\setlength{\parindent}{0pt}
\hyphenpenalty=1000
\tolerance=1000
\sloppy



\begin{document}

\section*{Skupina 18: Kemijski grafi}
\textit{Avtorja: David Planinšek Šilc, Lenart Žerdin \\ Datum: 20. 12. 2024 \\}

\subsection*{Opis problema}
Najina naloga temelji na raziskovanju kemijskih grafov in njihovem
$\sigma_t^{f(n)}(G)$ indeksu. Zanima naju, kako se indeks v odvisnosti od
različnih $f(n)$ spreminja. Omejila
sva se na funkcije $f(n) = \frac{1}{n}$ in $f(n) = c$ za 
$c \in (0, 1)$, kjer sva podrobneje gledala tiste $c$, ki so 
blizu $0$ in $1$.

\subsection*{Definicije}

\begin{enumerate}
    \item Graf je kemijski, če so vsa njegova vozlišča stopnje največ 4.
        Če ima kemijski graf $a_i$ vozlišč stopnje $i$, $1 \leq i \leq 4$,
        potem njegovo stopenjsko zaporedje označimo kot $(1^{a_1}, 2^{a_2}, 3^{a_3}, 4^{a_4})$. 

    \item Definiramo totalni $\sigma$-indeks iregularnosti, v angleščini
        `Total $\sigma$-irregularity', $\sigma_t^{f(n)}(G)$ kot:
        \[
        \sigma_t^{f(n)}(G) = \sum_{\{u,v\} \subseteq V(G)} \left| d_G(u) - d_G(v) \right|^{f(n)},
        \]
        kjer je $n = |V(G)|$ in je $f(n)$ funkcija, definirana za $n \geq 4$. 
\end{enumerate}

\subsection*{Izrek}
Naj bo $n \geq 7$, $f(n) \leq \log_3 \left( \frac{3n^2}{3n^2 - 8} \right)$, in naj bo $(1^{a_1}, 2^{a_2}, 3^{a_3}, 4^{a_4})$ stopenjsko zaporedje kemijskega grafa $G$ z maksimalno vrednostjo $\sigma_t^{f(n)}(G)$. Potem velja:
\begin{enumerate}
    \item Če $n = 4k - 1$, potem $a_1 = a_3 = a_4 = k$ in $a_2 = k - 1$.
    \item Če $n = 4k$, potem $a_1 = a_2 = a_3 = a_4 = k$.
    \item Če $n = 4k + 1$, potem $a_1 = a_2 = a_3 = k$ in $a_4 = k + 1$.
    \item Če $n = 4k + 2$, potem velja bodisi $a_1 = a_3 = k$ in $a_2 = a_4 = k + 1$, bodisi $a_1 = a_3 = k + 1$ in $a_2 = a_4 = k$. 
\end{enumerate}

Ker je za kemijske grafe razlika med stopnjami vozlišč omejena, domnevamo naslednje: 

\begin{itemize}
    \item \textbf{Domneva 1:} Isti grafi, kot v Izreku, imajo maksimalno vrednost za $\sigma_t^{f(n)}$, če je $f(n) = \frac{1}{n}$. 
    \item \textbf{Domneva 2:} Isti grafi, kot v Izreku, imajo maksimalno vrednost za $\sigma_t^{f(n)}$, če je $f(n) = c$, kjer je $c$ konstanta v intervalu $(0, 1)$. 

\end{itemize}

\subsection*{Algoritmi in psevdokode}
Za preverjanje domnev sva napisala algoritme, ki generirajo kemijske grafe in izračunajo njihov $\sigma_t^{f(n)}$ indeks.
Najprej sva se lotila sistematičnega iskanja za grafe z $n$ vozlišči, kjer je $n \in [7, 14]$, $n \in \mathbb{N}$.
Za večje grafe sva zaradi predolgega trajanja iskanja uporabila algoritma Hill climbing in Simulated annealing. Natančneje
za grafe velikosti $n \in [15, 20] \cup [50, 53] \cup [100, 102]$.

\subsubsection*{Sistematično iskanje}
Pri sistematičnem iskanju sva generirala vse možne konfiguracije oziroma
stopenjska zaporedja za različne $n$, preverila, če tak graf sploh obstaja
in izračunala $\sigma_t^{f(n)}(G)$ za različne $f(n)$. Nato sva
izbrala tiste grafe, kjer je bila pri določenih $f(n)$ vrednostjo $\sigma_t^{f(n)}(G)$
največja.


\subsubsection*{Psevdokoda za sistematično iskanje}

\begin{algorithmic}[1]
\Function{DegreeConfiguration}{graf}
    \State $degree\_counts \gets [0, 0, 0, 0]$
    \ForAll{$degree$ v $graf.degree()$}
        \State $degree\_counts[degree - 1] \gets degree\_counts[degree - 1] + 1$
    \EndFor
    \State \Return $(degree\_counts[0], degree\_counts[1], degree\_counts[2], degree\_counts[3])$
\EndFunction

\Function{GenerateUniqueChemicalGraphsConfigs}{$n$}
    \State $unique\_configs \gets []$
    \ForAll{$g$ v $graphs.nauty\_geng(f"{n} -c -D4")$}
        \State $config \gets DegreeConfiguration(g)$
        \If{$config \notin unique\_configs$}
            \State Dodaj $config$ v $unique\_configs$
        \EndIf
    \EndFor
    \State \Return $unique\_configs$
\EndFunction

\Function{SigmaTotalIrregularityFromConfig}{$config, f_n$}
    \State $a_1, a_2, a_3, a_4 \gets config$
    \State $degree\_list \gets [1] \times a_1 + [2] \times a_2 + [3] \times a_3 + [4] \times a_4$
    \State $sigma_t \gets 0$
    \For{$i \gets 0$ do $|degree\_list| - 1$}
        \For{$j \gets i + 1$ do $|degree\_list|$}
            \State $sigma_t \gets sigma_t + |degree\_list[i] - degree\_list[j]|^{f_n}$
        \EndFor
    \EndFor
    \State \Return $sigma_t$
\EndFunction
\end{algorithmic}

\vspace*{1cm}

\subsubsection*{Hill climbing algoritem}
Hill climbing algoritem je optimizacijski algoritem,
ki iterativno izboljšuje trenutno rešitev tako, da na vsakem koraku
poišče sosednjo rešitev z boljšo, v najinem primeru večjo, $\sigma_t^{f(n)}(G)$
vrednostjo. Algoritem sva ustavila po 100000 iteracijah. 

\subsubsection*{Psevdokoda za Hill climbing algoritem}



    \begin{algorithmic}[1]
    
    \Function{GenerateInitialGraph}{$n$}
        \State $g \gets$ prazen graf
        \State Dodaj vsa vozlišča $0, \dots, n-1$ v $g$
        \State $available \gets [0, \dots, n-1]$
        \State $connected \gets [\text{izberi naključno vozlišče iz } available]$
        
        \While{$available$ ni prazno}
            \State $u \gets$ naključno izbrano vozlišče iz $connected$
            \State $v \gets$ odstrani naključno vozlišče iz $available$
            \If{$\text{degree}(u) < 4$}
                \State Dodaj povezavo $(u, v)$ v $g$
                \State Dodaj $v$ v $connected$
            \Else
                \State Vrni $v$ nazaj v $available$
            \EndIf
        \EndWhile
        \State \Return $g$
    \EndFunction
    
    \Function{MutateGraph}{$g, u, v$}
        \If{$g$ vsebuje povezavo $(u, v)$}
            \State Odstrani povezavo $(u, v)$ iz $g$
            \If{$g$ je povezan}
                \State \Return $g$
            \Else
                \State Dodaj nazaj $(u, v)$
                \State \Return $g$
            \EndIf
        \Else
            \State Dodaj povezavo $(u, v)$ v $g$
            \If{$\max(\text{degree}(g)) \leq 4$}
                \State \Return $g$
            \Else
                \State Odstrani $(u, v)$
                \State \Return $g$ 
            \EndIf
        \EndIf
    \EndFunction 
    
    \end{algorithmic}

    \vspace*{1cm}
   
    \begin{algorithmic}[1]
    
    \Function{HillClimbing}{$n, f, iterations$}
        \State $current\_graph \gets$ GenerateInitialGraph($n$)
        \State $degree\_counts \gets$ seznam stopenj v $current\_graph$
    
        \For{$i = 1$ do $iterations$}
            \State $vertices \gets$ seznam vozlišč v $current\_graph$
            \State $(u, v) \gets$ naključno izbran par vozlišč iz $vertices$
            
            \State $original\_contribution \gets 0$
            \ForAll{$w$ v $vertices$}
                \If{$w \neq u$}
                    \State $org\_contribution += |degree\_counts[u] - degree\_counts[w]|^{f_n}$
                \EndIf
                \If{$w \neq v$ in $w \neq u$}
                    \State $org\_contribution += |degree\_counts[v] - degree\_counts[w]|^{f_n}$
                \EndIf
            \EndFor
    
            \State $new\_graph \gets$ MutateGraph($current\_graph, u, v$)
            \State $new\_degree\_counts \gets$ seznam stopenj v $new\_graph$
    
            \State $new\_contribution \gets 0$
            \ForAll{$w$ v $vertices$}
                \If{$w \neq u$}
                    \State $new\_contribution += |degre\_counts[u] - degree\_counts[w]|^{f_n}$
                \EndIf
                \If{$w \neq v$ in $w \neq u$}
                    \State $new\_contribution += |degree\_counts[v] - degree\_counts[w]|^{f_n}$
                \EndIf
            \EndFor
    
            \If{$new\_contribution > original\_contribution$}
                \State $current\_graph \gets new\_graph$
                \State $degree\_counts \gets new\_degree\_counts$
            \EndIf
        \EndFor
    
        \State $sigma_t \gets 0$
        \ForAll{$(x, y) \in$ pari vozlišč v $current\_graph$}
            \State $sigma_t += |degree(x) - degree(y)|^{f_n}$
        \EndFor
    
        \State \Return $(current\_graph, sigma_t)$
    \EndFunction 
    
    \end{algorithmic}
    
\\

\subsubsection*{Simulated annealing algoritem}
Problem pri Hill climbing algoritmu je, da se lahko zatakne v lokalnem 
maksimumu. Simulated annealing algoritem je pristop, ki se temu izogne,
tako da včasiih sprejema tudi slabše rešitve. Algoritem sva ustavila po
100000 iteracijah.

\subsubsection*{Psevdokoda za Simulated annealing algoritem}
    \begin{algorithmic}[1]
    \Function{Simulated Annealing}{$n,f_n,iterations, T, \alpha$}    
        \State $T= 1$
        \State $\alpha = 0.99$
        \State $\Delta \gets new\_contribution - original\_contribution$
        \If{$\Delta > 0$ \textbf{or} $random() < \exp(\Delta / T)$}
            \State $current\_graph \gets new\_graph$
            \State $degree\_counts \gets new\_degree\_counts$
        \EndIf
            
        \State $T \gets T \cdot \alpha$ 
    \EndFunction
    \end{algorithmic}


\vspace*{0.5cm}

\subsection*{Tabele in grafi}

\subsubsection*{Tabela za sistematično iskanje}

{\footnotesize
\[
\begin{array}{c|c|c|c|c|c|c|c|c|c|c}
    n & \frac{1}{n} & 0.0001 & 0.1  & 0.2 & 0.45 & 0.55 & 0.8 & 0.9 & 0.9995 \\
    \hline
    7  & (2, 1, 2, 2) & (2, 2, 2, 1) & (2, 1, 2, 2) & (2, 1, 2, 2) & (2, 1, 2, 2) & (3, 1, 1, 2) & (3, 0, 1, 3) & (3, 0, 1, 3) & (3, 0, 1, 3) &  \\
    8  & (2, 2, 2, 2) & (2, 2, 2, 2) & (2, 2, 2, 2) & (2, 2, 2, 2) & (3, 1, 1, 3) & (3, 1, 1, 3) & (3, 1, 1, 3) & (4, 0, 0, 4) & (4, 0, 0, 4) &  \\
    9  & (2, 2, 2, 3) & (2, 3, 2, 2) & (2, 2, 2, 3) & (2, 2, 2, 3) & (3, 2, 1, 3) & (3, 2, 1, 3) & (4, 1, 0, 4) & (4, 1, 0, 4) & (4, 1, 0, 4) &  \\
    10 & (3, 2, 3, 2) & (3, 2, 3, 2) & (3, 2, 3, 2) & (3, 2, 3, 2) & (4, 1, 2, 3) & (4, 1, 2, 3) & (5, 0, 1, 4) & (5, 0, 1, 4) & (5, 0, 1, 4) &  \\
    11 & (3, 2, 3, 3) & (3, 3, 3, 2) & (3, 2, 3, 3) & (3, 2, 3, 3) & (4, 2, 2, 3) & (4, 1, 2, 4) & (5, 0, 1, 5) & (5, 0, 1, 5) & (5, 0, 1, 5) &  \\
    12 & (3, 3, 3, 3) & (3, 3, 3, 3) & (3, 3, 3, 3) & (3, 3, 3, 3) & (4, 2, 2, 4) & (4, 2, 2, 4) & (5, 1, 1, 5) & (5, 1, 1, 5) & (6, 0, 0, 6) &  \\
    13 & (3, 3, 3, 4) & (3, 3, 3, 4) & (3, 3, 3, 4) & (3, 3, 3, 4) & (4, 3, 2, 4) & (4, 2, 2, 5) & (5, 1, 1, 6) & (6, 1, 0, 6) & (6, 1, 0, 6) &  \\
    14 & (4, 3, 4, 3) & (4, 3, 4, 3) & (4, 3, 4, 3) & (4, 3, 4, 3) & (5, 2, 3, 4) & (5, 2, 3, 4) & (6, 1, 2, 5) & (7, 0, 1, 6) & (7, 0, 1, 6) &  
\end{array}
\]
}

\vspace*{0.5cm}

\subsubsection*{Tabela za Hill climbing algoritem}

{\footnotesize
\[
\begin{array}{c|c|c|c|c|c|c|c}
    n & \frac{1}{n} & 0.001 & 0.1 & 0.5 & 0.9 & 0.995 \\
    \hline
    15 & (4, 3, 4, 4) & (4, 3, 4, 4) & (5, 2, 3, 5) & (5, 2, 3, 5) & (6, 1, 2, 6) & (7, 0, 1, 7) & \\
    16 & (4, 4, 4, 4) & (4, 4, 4, 4) & (5, 3, 3, 5) & (5, 3, 3, 5) & (6, 1, 2, 7) & (6, 1, 2, 7) & \\
    17 & (4, 4, 4, 5) & (4, 4, 4, 5) & (5, 3, 3, 6) & (6, 3, 2, 6) & (6, 2, 2, 7) & (7, 1, 1, 8) & \\
    18 & (4, 5, 4, 5) & (5, 4, 5, 4) & (5, 4, 3, 6) & (7, 2, 3, 6) & (7, 2, 1, 8) & (8, 0, 2, 8) & \\
    19 & (5, 4, 5, 5) & (5, 4, 5, 5) & (6, 3, 4, 6) & (7, 3, 3, 6) & (7, 1, 3, 8) & (9, 0, 1, 9) & \\
    20 & (5, 5, 5, 5) & (5, 5, 5, 5) & (6, 4, 4, 6) & (7, 3, 3, 7) & (7, 3, 1, 9) & (8, 1, 2, 9) & \\
    50 & (12, 13, 12, 13) & (12, 13, 12, 13) & (15, 10, 9, 16) & (17, 8, 9, 16) & (21, 4, 3, 22) & (21, 4, 1, 24) & \\
    51 & (13, 12, 13, 13) & (13, 12, 13, 13) & (16, 9, 10, 16) & (17, 8, 9, 17) & (21, 4, 3, 23) & (24, 1, 0, 26) & \\
    52 & (13, 13, 13, 13) & (13, 13, 13, 13) & (16, 10, 10, 16) & (17, 9, 9, 17) & (22, 3, 4, 23) & (22, 3, 2, 25) & \\
    53 & (13, 13, 13, 14) & (13, 13, 13, 14) & (17, 10, 9, 17) & (18, 9, 8, 18) & (23, 3, 3, 24) & (23, 3, 1, 26) & \\
    100 & (25, 25, 25, 25) & (25, 25, 25, 25) & (31, 19, 19, 31) & (34, 16, 16, 34) & (44, 5, 6, 45) & (47, 3, 1, 49) & \\
    101 & (25, 25, 25, 26) & (25, 25, 25, 26) & (32, 19, 18, 32) & (34, 17, 16, 34) & (45, 5, 5, 46) & (45, 5, 1, 50) & \\
    102 & (25, 26, 25, 26) & (25, 26, 25, 26) & (32, 19, 18, 33) & (34, 17, 16, 35) & (46, 4, 6, 46) & (44, 6, 2, 50) & \\
    103 & (26, 25, 26, 26) & (26, 25, 26, 26) & (27, 24, 25, 27) & (35, 16, 17, 35) & (47, 4, 5, 47) & (49, 2, 1, 51) & \\
    1000 & (250, 250, 250, 250) & (250, 250, 250, 250) & (264, 236, 236, 264) & (337, 163, 163, 337) & (354, 128, 58, 460) & (353, 112, 37, 498) & \\
    1001 & (250, 250, 250, 251) & (250, 250, 250, 251) & (264, 236, 236, 265) & (337, 163, 163, 338) & (361, 129, 51, 460) & (361, 112, 31, 497) & \\

\end{array}
\]
}

\vspace*{0.5cm}

\subsubsection*{Tabela za Simulated annealing algoritem}

{\footnotesize
\[
\begin{array}{c|c|c|c|c|c|c|c}
    n & \frac{1}{n} & 0.001 & 0.1 & 0.5 & 0.9 & 0.995 & \\
    \hline
    15 & (4, 3, 4, 4) & (4, 3, 4, 4) & (4, 3, 4, 4) & (5, 2, 3, 5) & (6, 1, 2, 6) & (7, 0, 1, 7) & \\
    16 & (4, 4, 4, 4) & (4, 4, 4, 4) & (4, 4, 4, 4) & (5, 3, 3, 5) & (7, 1, 1, 7) & (6, 1, 2, 7) & \\
    17 & (4, 4, 4, 5) & (4, 4, 4, 5) & (4, 4, 4, 5) & (6, 3, 2, 6) & (6, 2, 2, 7) & (7, 1, 1, 8) & \\
    18 & (4, 5, 4, 5) & (5, 4, 5, 4) & (5, 4, 5, 4) & (7, 2, 3, 6) & (6, 2, 2, 8) & (8, 1, 0, 9) & \\
    19 & (5, 4, 5, 5) & (5, 4, 5, 5) & (5, 4, 5, 5) & (6, 3, 4, 6) & (8, 1, 2, 8) & (8, 1, 0, 10) & \\
    20 & (5, 5, 5, 5) & (5, 5, 5, 5) & (5, 5, 5, 5) & (7, 3, 3, 7) & (9, 1, 1, 9) & (8, 1, 2, 9) & \\
    50 & (12, 13, 12, 13) & (12, 13, 12, 13) & (13, 12, 11, 14) & (17, 8, 9, 16) & (20, 4, 4, 22) & (24, 0, 2, 24) & \\
    51 & (13, 12, 13, 13) & (13, 12, 13, 13) & (14, 12, 12, 13) & (17, 8, 9, 17) & (21, 4, 3, 23) & (23, 1, 1, 26) & \\
    52 & (13, 13, 13, 13) & (13, 13, 13, 13) & (14, 12, 12, 14) & (17, 9, 9, 17) & (22, 3, 4, 23) & (24, 1, 2, 25) & \\
    53 & (13, 13, 13, 14) & (13, 13, 13, 14) & (14, 13, 12, 14) & (18, 9, 8, 18) & (23, 3, 3, 24) & (25, 1, 1, 26) & \\
    100 & (25, 25, 25, 25) & (25, 25, 25, 25) & (26, 24, 24, 26) & (34, 16, 16, 34) & (42, 7, 6, 45) & (46, 3, 2, 49) & \\
    101 & (25, 25, 25, 26) & (25, 25, 25, 26) & (26, 24, 24, 27) & (34, 17, 16, 34) & (46, 5, 4, 46) & (44, 6, 0, 51) & \\
    102 & (25, 26, 25, 26) & (25, 26, 25, 26) & (26, 25, 24, 27) & (34, 17, 16, 35) & (45, 6, 5, 46) & (46, 4, 2, 50) & \\
    103 & (26, 25, 26, 26) & (26, 25, 26, 26) & (27, 24, 25, 27) & (35, 16, 17, 35) & (47, 4, 5, 47) & (42, 9, 0, 52) & \\
    1000 & (250, 250, 250, 250) & (250, 250, 250, 250) & (264, 236, 236, 264) & (337, 163, 163, 337) & (360, 129, 52, 459) & (351, 111, 41, 497) & \\
    1001 & (250, 250, 250, 251) & (250, 250, 250, 251) & (264, 236, 236, 265) & (337, 163, 163, 338) & (358, 124, 58, 461) & (356, 112, 34, 499) & \\

\end{array}
\]
}

\vspace*{1cm}


\subsubsection*{Graf $\sigma_t^{f(n)}(G)$ indeksa v odvisnosti od števila vozlišč $n$}



\subsection*{Rezultati in ugotovitve}
Ugotovila sva, da so največje vrednosti $\sigma_t^{f(n)}(G)$ za $f(n) = \frac{1}{n}$ dosežene 
pri grafih, ki imajo stopenjsko zaporedje enako kot v izreku. Enako velja za $f(n) = c$,
kjer so vrednosti pa za $c$ blizu $0$. Pri $c$ blizu $1$ pa so vrednosti $\sigma_t^{f(n)}(G)$
maksimizirane takrat, ko sta zunanja člena stopenjskega zaporedja $(1^{a_1}, 2^{a_2}, 3^{a_3}, 4^{a_4})$
čim večja, notranja pa čim manjša in sicer izgledajo tako:

\subsubsection*{Trditev}
Naj bo $n \geq 7$, $f(n) = c$, za $c$ 'zelo blizu' $1$ in naj bo $(1^{a_1}, 2^{a_2}, 3^{a_3}, 4^{a_4})$
stopenjsko zaporedje kemijskega grafa $G$ z maksimalno vrednostjo $\sigma_t^{f(n)}(G)$. Potem velja:
\begin{enumerate}
    \item Če $n = 4k - 1$, potem $a_1 = 2k - 1$, $a_2 = 1$, $a_3 = 0$ in $a_4 = 2k - 1$.
    \item Če $n = 4k$, potem $a_1 = a_4 = 2k$ in $a_2 = a_3 = 0$.
    \item Če $n = 4k + 1$, potem $a_1 = a_4 = 2k$ in $a_2 = 1$ ($a_3 = 0$) ali $a_3 = 1$ ($a_2 = 0$) .
    \item Če $n = 4k + 2$, potem $a_1 = 2k$, $a_2 = 1$, $a_3 = 0$ in $a_4 = 2k + 1$. 
\end{enumerate}


\end{document}
